// 👉 TASK 1 - Understand the existing code 👈
function moduleProject2() {
  // 👇 WORK BELOW THIS LINE 👇
  let startTime = new Date().getTime(); // Record start time
  function getTimeElapsed() { // eslint-disable-line
    // To be used at end of game to get elapsed time; p.info
    let currentTime = new Date().getTime();
    return (currentTime - startTime) / 1000; // divide by 1000 to covert the time in milliseconds to seconds
  }

  // Setting up the footer content //
  let footer = document.querySelector("footer");
  let currentYear = new Date().getFullYear();
  footer.textContent = `© BLOOM INSTITUTE OF TECHNOLOGY ${currentYear}`;
  
  /** // Not necessary due to concise rework in step 3
  let keys = {
    // To easily check `event.key` on keyboard events. If not included console will return a reference error.
    space: " ",
    up: "ArrowUp",
    right: "ArrowRight",
    down: "ArrowDown",
    left: "ArrowLeft",
  };
  */

  // Helper function to grab all squares //
  const getAllSquares = () => document.querySelectorAll(".square");

  // Populating the grid with rows and squares //
  for (let n = 0; n < 5; n++) { // 5 iterations // Creating the rows //
    let row = document.createElement("div"); // building a row
    document.querySelector("#grid").appendChild(row); // appending the built row
    row.classList.add("row"); // adding 'row' to classList
    for (let m = 0; m < 5; m++) { // inner loop: 5 times per row: creates 5 squares (or indices)
      let square = document.createElement("div"); // building one square
      square.classList.add("square"); // adding 'square' to classList
      row.appendChild(square); // appending the built square classList
      square.addEventListener("click", () => {
        // 👉 TASK 2 - Use a click handler to target a square 👈
        if (!square.classList.contains("targeted")) {
          const squares = getAllSquares().forEach((sq) => { // eslint-disable-line
            document.querySelector(".targeted").classList.remove("targeted");
            square.classList.add("targeted");
            /**
             **We choose to include '!' (not) because why?**
             *Because we are looking to clear the classList 'targeted'
             * -- Why clear the attributed classList?:
             * --- Foresight to not comeback and recode or overcode...
             * --- The intended result is to not have miltiple squares be 'targeted' simultaneously and have a resulting border styling from being .targeted...
             * In short:
             * -- We want to clear the 'targeted' square to allow a new square to become 'targeted' if/when a new square is selected...
             * Overall:
             * -- When a new square is clicked, that square is given the classList 'targeted' as well as the paired CSS selector tag '.targeted'. 
             * -- The previous square is cleared of the both...
             * **NOTE:**
             * -- querySelector('.targeted') is specifying the CSS selector tag (denoted in js by using the '.')
             * -- The second 'targeted' is the classList of the square which has the CSS selector tag attributes paired to it.*/
          });
        }
      });
    }
  }
  document
    .querySelector(".row:nth-child(3)") // Specifying 3rd row, 3rd square
    .children[2].classList.add("targeted"); // Initial/specific square being targeted

  /** Below: is a Helper function to obtain 5 random indices (row/column array of squares: each square with an index) (0-24 : the # of squares) to put mosquitoes in.
   * Math.random() * 25 --- scales the result, giving a random decimal number between above 0 and below 25.
   * Math.floor() --- rounds down the Math.random() decimal to the nearest whole number, scaling from 0 to 24.
   * if (!randomInts.includes(randomInt)) --- checks if the integer is NOT already in the randomInts array 
      * The '!' --- alters the return value to 'true' so if integer is not w/in *include()* 0 - 24.
   * randomInts.push(randomInt) --- if return is 'true', that checked integer is added to the randomInts array
   * The randomInts array is used later to structure the grid of squares and the  
*/
  function generateRandomIntegers() {
    let randomInts = [];
    while (randomInts.length < 5) {
      let randomInt = Math.floor(Math.random() * 25);
      if (!randomInts.includes(randomInt)) {
        randomInts.push(randomInt);
      }
    }
    return randomInts;
  }
  let allSquares = getAllSquares();
  generateRandomIntegers().forEach((randomInt) => { // Puts 'live' skeeter in 5 random squares disignated by the random indices generated by generateRandomIntegers() fx
    let mosquito = document.createElement("img");
    mosquito.src = "./mosquito.png"; // style: skeeter source img
    mosquito.style.transform = `rotate(${Math.floor(
      Math.random() * 359
    )}deg) scale (${Math.random() * 0.4 + 0.8})`; // style: skeeter angle of display on a square
    mosquito.dataset.status = "alive"; // style: status style set by CSS applied
    allSquares[randomInt].appendChild(mosquito);
  });
    // 👉 TASK 3 - Use the arrow keys to highlight a new square 👈
  /** document.addEventListener("keydown", (evt) => { // for arrow-key and space bar action requiring event action/result
    
    let isUp = evt.key === keys.up; // Has 'isUp' = the up key event if the event.key was the 'up' key with the "ArrowUp" value
    let isDown = evt.key === keys.down;
    let isLeft = evt.key === keys.left;
    let isRight = evt.key === keys.right;

    let targeted = document.querySelector(".targeted"); // declares a 3rd 'targeted', but is variable within the keydown eventListener; Not a class or selector: Allows for determining which square is targeted, once passsing the following conditional in relation to the key pressed.
    if (isUp) {
      if (targeted.parentElement.previousElementSibling) {
        let rowIdx = Array.from(targeted.parentElement.children).indexOf(
          targeted
        );
        targeted.classList.remove("targeted");
        targeted.parentElement.previousElementSibling.children[
          rowIdx
        ].classList.add("targeted");
      } 
      /** 
       * squares are children, parentElement is the row, siblings pertain to the child or parent in context
       * rowIdx : indices are w/in arrays, so Array.from is applied to transform the array like object into an array. rowIdx takes the index of the square (current) of the parent row to then apply 'targeted' to the same index on the next row moved to.
       * classList.add : the previous rows sibiling (new row) now attains targeted classList on the child square @ rowIDx (same square index, but on a new row)

    } else if (isDown) {
      if (targeted.parentElement.nextElementSibling) {
        let rowIdx = Array.from(targeted.parentElement.children).indexOf(
          targeted
        );
        targeted.classList.remove("targeted");
        targeted.parentElement.nextElementSibling.children[
          rowIdx
        ].classList.add("targeted");
      }
    } else if (isLeft) {
      if (targeted.previousElementSibling) {
        targeted.classList.remove("targeted");
        targeted.previousElementSibling.classList.add("targeted");
      } 
      /** 
       * if last square was targeted, moving to the next square will remove classList & apply to new square
       * When the targeted square is the left-most square, the square will be reselected
   
    } else if (isRight) {
      if (targeted.nextElementSibling) {
        targeted.classList.remove("targeted");
        targeted.nextElementSibling.classList.add("targeted");
      } 
      // 'nextElementSibling' has the same parameters, but specific to the opposite direction as what was previously coded above
    }
  }); 
  */
  
  // Streamlined keydown eventListener // 
  document.addEventListener("keydown", (evt) => {
    const gameKeys = {
      ArrowUp: () => targeted.parentElement.previousElementSibling.children[rowIdx],
      ArrowDown: () => targeted.parentElement.nextElementSibling?.children[rowIdx],
      ArrowLeft: () => targeted.previousElementSibling,
      ArrowRight: () => targeted.nextElementSibling,
      " ": () => {
        let mosquito = targeted.querySelector("img"); // if the targeted square has a skeeter the following conditional is performed
        if (mosquito) {
          mosquito.dataset.status = "dead";
          mosquito.parentElement.style.backgroundColor = 'crimson'
          mosquito.remove();
        }
      }
    };
    let targeted = document.querySelector(".targeted");
    let rowIdx = Array.from(targeted.parentElement.children).indexOf(targeted);
    let newTarget = gameKeys[evt.key](); // if the key pressed was an arrow key, the eventListener will perform that direction move
  
    if (newTarget) {
      targeted.classList.remove("targeted");
      newTarget.classList.add("targeted");
    }
  
    // 👉 TASK 4 - Use the space bar to exterminate a mosquito 👈
          // ---> added to Streamlined keydown eventListener as " " //

    // Combining all click and keydown eventListeners under one function is possible but not neccessary due time and some differences in the input event actions, nor is it conducive for viewer understanding

    // 👉 TASK 5 - End the game 👈
    /**
     * How could the program know we have reached the end of the game?
        * The amount of 'live' skeeters are 0 (hint: use ! and .length)
        * Determined by the number of skeeters with dataset.status = 'alive' vs 'dead'
     * Exchange the header paragraph text to display the time elapsed since loading and reaching the end of the game
     * Add a 'Restart' button to the header when game ends
        * Clicking on restart button will reload the page  
    */
    let pattiMayonaiseHitEverySkeeter = document.querySelectorAll('[data-status=alive]') // '[]' is used to focus on the attibute-selector w/in it; in this would be =alive
    if (!pattiMayonaiseHitEverySkeeter.length){
      let gameTimer = getTimeElapsed()
      document.querySelector('p.info').textContent = 
      `You hit every skeeter in ${gameTimer} seconds!`

      // Play Again / Restart Button // Adds conditional check to see if button was already created; negates duplication of said button due to dual " " eventListener action
      let playAgainButton = document.querySelector('button') // seeks for the play again button
      if (!playAgainButton) {
        playAgainButton = document.createElement('button') // if no button, it will create it
        playAgainButton.textContent = 'Play Again'
        playAgainButton.addEventListener('click', () => {
          location.reload() // reloads the page
        })
      }
      document.querySelector('h2').insertAdjacentElement('afterend', playAgainButton) // insertAdjacentElement('position', object) : afterend, beforeend, afterstart,...
      playAgainButton.focus() // allows the keyboard tab button to move onto the button, highlighting it and allowing selection using the keyboard enter button
    }
  });
  // 👆 WORK WORK ABOVE THIS LINE 👆
}

// ❗ DO NOT MODIFY THE CODE BELOW
// ❗ DO NOT MODIFY THE CODE BELOW
// ❗ DO NOT MODIFY THE CODE BELOW
if (typeof module !== "undefined" && module.exports)
  module.exports = { moduleProject2 };
else moduleProject2();
